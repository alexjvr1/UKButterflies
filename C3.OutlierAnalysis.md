# Aricia agestis genome scan

Aim: set up code for genome scan between museum and modern, and modern core vs modern expanding

1. Genome scan

2. Sort according to Heliconius gff. 

3. Compare Manhattan plots

4. identify genes



## Prepare the data

The samples in the raw vcf need to be renamed with shorter names. 
```
module load apps/bcftools-1.8

##see the current names
bcftools query -l 

10-AAg-19-1900-10_190312_L005_cutadapt_filtered_R1.fastq.gz
11-AAg-19-1900-11_190312_L005_cutadapt_filtered_R1.fastq.gz
12-AAg-19-1900-12_190312_L005_cutadapt_filtered_R1.fastq.gz
...

##Create a file with two columns: old_name new_name

nano C3.newnames

10-AAg-19-1900-10_190312_L005_cutadapt_filtered_R1.fastq.gz	AAg-19-1900-10_museum
11-AAg-19-1900-11_190312_L005_cutadapt_filtered_R1.fastq.gz	AAg-19-1900-11_museum
12-AAg-19-1900-12_190312_L005_cutadapt_filtered_R1.fastq.gz	AAg-19-1900-12_museum
...

bcftools reheader -s C3.newnames C3.raw.bcf > C3.raw.newnames.bcf
```

The file should be filtered correctly - minimum 18 individuals genotyped in each of the populations (museum, modernCore, modernExp)

The filtering script can be found [here](https://github.com/alexjvr1/UKButterflies/blob/master/03c_variants_filtering_ExpandingPops_July2019.sh)

After filtering generate the intersecting files (ie. vcf for each population with only loci from found in both populations). 

```
bcftools isec -p dir museum_xxx.bcf modern_xxxx.bcf

##for more than two files: 

bcftools isec -p dir -n 3 museum_xxx.bcf modernCore_xxx.bcf modernExp_xxx.bcf
```

Initially we'll use the masked file to compare Fst between annotated loci only
```
module load apps/bedtools2

bedtools subtract -header -a 0002.vcf -b ../../../RefGenome/genome.mod.gff > 0002.masked.vcf

bedtools subtract -header -a 0003.vcf -b ../../../RefGenome/genome.mod.gff > 0003.masked.vcf

## merge all of these files

bcftools view -O b 0002.masked.vcf > 0002.masked.bcf

bcftools view -O b 0003.masked.vcf > 0003.masked.bcf

bcftools merge 0002.masked.bcf 0003.masked.bcf > C3.masked.mus.mod.bcf

```


Remove all loci with high levels of heterozygosity as these will skew the Fst outlier analysis
```
#this filters all loci with het excess (p<0.05)
vcftools --vcf C3.3pops.masked.vcf --hwe 0.05  

VCFtools - v0.1.12b
(C) Adam Auton and Anthony Marcketta 2009

Parameters as interpreted:
	--vcf C3.3pops.masked.vcf
	--max-alleles 2
	--hwe 0.05

After filtering, kept 129 out of 129 Individuals
After filtering, kept 1948712 out of a possible 2102050 Sites
Run Time = 63.00 seconds

```


Load R on bluecrystal
```
###module load languages/R3.

sessionInfo()
R version 3.5.0 RC (2018-04-16 r74618)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Scientific Linux release 6.4 (Carbon)

Matrix products: default
BLAS: /cm/shared/languages/R-3.5-ATLAS/lib64/R/lib/libR.so
LAPACK: /cm/shared/languages/R-3.5-ATLAS/lib64/R/lib/libRlapack.so

locale:
 [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
 [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
 [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
[1] compiler_3.5.0 tools_3.5.0   
```

Read into R 
```
library(vcfR)

obj.vcfR <- read.vcfR("C3.3pops.masked.hardy0.05.recode.vcf")

geno <- extract.gt(obj.vcfR) # Character matrix containing the genotypes
position <- getPOS(obj.vcfR) # Positions in bp
chromosome <- getCHROM(obj.vcfR) # Chromosome information

G <- matrix(NA, nrow = nrow(geno), ncol = ncol(geno))

G[geno %in% c("0/0", "0|0")] <- 0
G[geno  %in% c("0/1", "1/0", "1|0", "0|1")] <- 1
G[geno %in% c("1/1", "1|1")] <- 2
G[is.na(G)] <- 9  ##replace missing data with 9

table(as.vector(G))
```

Read in pop info data and reate a list
```
C3.popinfo <- read.table("pop.id", header=F)
colnames(C3.popinfo) <- c("id", "pop")
head(C3.popinfo)

                                  V1         V2
1 AAg-19-2016-01_modernCore.fastq.gz modernCore
2 AAg-19-2016-02_modernCore.fastq.gz modernCore
3 AAg-19-2016-03_modernCore.fastq.gz modernCore
4 AAg-19-2016-04_modernCore.fastq.gz modernCore
5 AAg-19-2016-05_modernCore.fastq.gz modernCore
6 AAg-19-2016-06_modernCore.fastq.gz modernCore



##create list
sim1data = list(position=position, chromosome=chromosome, G=G, pop=C3.popinfo$pop, id=C3.popinfo$id) #creates a named list
str(sim1data)
List of 5
 $ position  : int [1:1948712] 185 191 198 202 224 249 288 292 293 301 ...
 $ chromosome: chr [1:1948712] "m_scaff_3" "m_scaff_3" "m_scaff_3" "m_scaff_3" ...
 $ G         : num [1:1948712, 1:129] 0 0 0 0 0 0 0 0 0 0 ...
 $ pop       : Factor w/ 3 levels "modernCore","modernExp",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ id        : Factor w/ 129 levels "AAg-10-2016-01_modernExp.fastq.gz",..: 90 91 92 93 94 95 96 97 98 99 ..
 
 
table(sim1data$pop)  ##check sample sizes for each population

modernCore  modernExp     museum 
        40         41         48 

```


## Genome scan

We'll use [OutFlank](https://htmlpreview.github.io/?https://github.com/whitlock/OutFLANK/blob/master/inst/doc/OutFLANKAnalysis.html) for the outlier analysis


First select a subset of loci to calculate the neutral Fst

```
library(OutFLANK)

my_fst <- MakeDiploidFSTMat(t(sim1data$G), locusNames = sim1data$position, popNames = sim1data$pop)

```






